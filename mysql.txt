MY SQL:
	Sub langauges of mysql:
	==> DDL (Data defination langauge)
	==> DML (Data manipulation langauge)
	==> DCL (Data control langauge)
	==> DQL	(Data query langauge)
	
DDL (Data defination langauge):
	==> Create
	==> Drop
	==> Alter
	==> Truncate
	==> Rename
	
DML (Data manipulation langauge):
	==> Insert
	==> update
	==> delete
DQL (Data query langauge):
	==> select
DCL (Data control langauge):
	==> Grant
	==> Revoke
TCL (Transaction control langauge):
	==> Commit 
	==> Roll back
	

Creating a database:
  Syntax:
	create database <database-name>
  Example:
	
	mysql> create database pp;
	Query OK, 1 row affected (0.02 sec)
To see the available database:
	Syntax:
		show databases
	Example:
		mysql> show databases;
	+--------------------+
	| Database           |
	+--------------------+
	| information_schema |
	| mysql              |
	| performance_schema |
	| pp                 |
	| practice           |
	| sakila             |
	| sys                |
	| world              |
	+--------------------+
	8 rows in set (0.00 sec)
How to switch the database:
	Syntax:
		use <database-name>
	Example:
		mysql> use practice;
		Database changed
How to delete database:
	Syntax:
		Drop database <database-name>
	Example:
		mysql> drop database pp;
		Query OK, 0 rows affected (0.02 sec)
Datatypes in Mysql:
	==> Numeric
	==> String
	==> Date
	
	String Datatypes:
		==> Char
		==> Varchar
		==> Binary
		==> Varcbinary
		==> Tinyblob
		==> Tinytext
		==> Mediumblob
		==> Mediumtext
		==> Blob
		==> Text
		==> Longblob
		==> Longtext
		==> enum
		==> set
	Example:
		create table data_string(a char,b varchar(20),c binary,d varbinary(20),e tinyblob,f tinytext,g mediumblob,h mediumtext,i blob,j text,k longblob,l
		longtext,m enum('a','b','c'),n set('d','e','f'));
	
	Numeric datatypes:
		INT, Float
		Int:
			==> Bit (i will take only one bit i.e 0 or 1)
			==> int
			==> tinyint
			==> smallint
			==> mediumint
			==> bigint
		Example:
			create table ten(a int,b tinyint,c smallint,d mediumint,e bigint);
		Float:
			==> Float(size,d)
				Float(p)
			==> Double(size,d)
			==> Decimal(size,d)
		Example:
			create table eleven(a float(10,2),b double(10,4),c decimal(10,5));
		Date:
			==> Date
			==> Datetime
			==> Time
			==> Timestamp
			==> Year
			
	Example:
	create table data_typess(a bit,b int,c tinyint,d smallint,e mediumint,f bigint,g double(10,1),h float(10,2),i decimal(10,2),j char,k varchar(20),
	l binary,m tinyblob,n tinytext,o mediumblob,p mediumtext,q text,r blob,s longblob,t longtext,u enum('a','b','c'),v set('d','e','f'),w date,
	x datetime,y time,z timestamp,aa year);
Creating a table:
	Syntax:
		CREATE TABLE table_name (
    column1 datatype,
    column2 datatype,
    column3 datatype,
	);
	==> While creating the table we have few factors
	1)Default    ==> we can give default value here if we didn't isert any value default value will insert
	2)Not null   ==> if we prsent to the coloumn then the coloumn shouldn't be null
	3)auto_increment ==> Then the value will increase automatically
	4)Primary key ==> it's a single or combination of coloumn which will define entire row
				==> it shouldn't be null	
				==> it's unique
	Example:
	create table students(id int not null auto_increment,name varchar(20) default 'XXXXX',dob date,pass enum('y','n'),primary key(id));
Inserting into table:
	Syntax:
		Insert into <table-name> values(value1,value2......n)
		insert into <table-name>(column1,column3) values(value1,value3);
		
	Example:
		insert into students values(1,'arun kumar','1999-05-10','y');
		insert into students values(2,'sai teja','1997-05-10','y');
		insert into students(id,name) values(3,'Harish s');
		insert into students(id,dob) values(4,'1998-7-12');
Adding a new coloumn to the table:
	==> we are using alter keyword for adding a new coloumns to the table
	==> Syntax:
		alter table <table-name> new_coloumn_name <data_type>
			here again we have two factors	
				==> after  ==> to create the new_coloumn after the existing coloumn_name
				==> first  ==> to create the new_coloumn at first only
		alter table <table-name> new_coloumn_name <data_type> after <coloumn_name>
		alter table <table-name> new_coloumn_name <data_type> first
	Example:
		alter table students add fathers_name varchar(50) after name;
		alter table students add aa bit first;
How to change a coloumn in sql table:
	==> for this also we will use alter keyword
	Syntax:
		alter table <table-name> change coloumn <existing_coloumn_name> <new_coloumn_name> data_type
		alter table <table-name> change coloumn <existing_coloumn_name> <existing_coloumn_name> data_type
	Example:
		alter table students change column fathers_name parent_name varchar(100);         ## This one for changing the coloumn_name
		alter table students change column name name varchar(60);                         ## This one for changing the data_type
Deleting the coloumn from table:
	==> For this also we will use alter keyword
	Syntax:
		alter table <table-name> drop coloumn <coloumn_name>
	Example:
		alter table students drop column aa;
How to delete the table:
	==> There are two keywords for deleting a table
		1)Drop ==> To delete the entire table data along with stracture
		2)Truncate ==> To delete only table data
	Syntax:
		Drop table <table_name> 
		Truncate table <table_name>
	Example:
		truncate table students;
		drop table students;
Selecting query from sql table:
	==> For this we will use select keyword
	Syntax:
		select <coloumn1,coloumn2...n> from table ==> to select particular coloumns
		select * from table ==> to select all the coloumns from table
		select coloumn1 as c1 from table ==> aliasing the coloumn1 name as c1 in result
	Example:
		select * from student;
		select name student_name from student;
		select age as a from student;
Updating the data in table:
	==> For this we will use a keyword UPDATE
	Syntax:
		update <table-name> set <coloumn>=<new_value> where <condition>
	Example:
		update student set age=24 where name='sai teja';
		update student set age=22 where age is null;
Deleting a data from the table:
	==> For this we are using a keyword called DELETE
		Syntax:
			delete from <table-name> where <condition>
		Example:
			delete from student where name ='zzzz';
			delete from student where name in ('xxxx','yyyy');
Dropping the primary key from table:
	==> For this we will use keyword Alter
	Syntax:
		alter table <table_name> drop primary key;
		if the primary key has auto_increment constraint then we need change that coloumn to same coloumn_name with out auto_increment then we need
		to drop primary key
	Example:
		alter table s drop primary key;
		alter table students change column id id int not null;
		alter table students drop primary key;
Adding the primary key to existing table
	==> For this we will use alter keyword
		Syntax:
			alter table <table_name> add primary key(<coloumn_name>)
		Example:
			alter table students add primary key(id);
Foreign key:
	==> The key which refers to the primary key in another table
	==> it work based on the primary key
	==> it will accepts only primary key
	==> Null values are accepted
	Syntax:
		create table <table-name>(<coloumn1>,<coloumn2>,....<coloumnn> foreign key(coloumn_name) refences(<table-name.coloumn_name>))
	Example:
		create table certificate_log(student_id int,certificate_id int,received_date date,foreign key(student_id) references student(id),foreign key(certificate_id) references certificates(id));
	in foreign if have 1 factor i.e.
	on delete cascade ==> which means if any row deleted from parent table automatically the record in children_table which belongs to that parent table record delete
	
	Syntax:
		create table <table-name>(<coloumn1>,<coloumn2>,....<coloumnn> foreign key(coloumn_name) refences(<table-name.coloumn_name>))
	Example:
		create table certificate_log(student_id int,certificate_id int,recieved_date date,foreign key(student_id) references student(id) on delete cascade,foreign key(certificate_id) references certificates(id) on delete cascade);
	
Constraints in sql:
		==> Not null ==> it won't accept null values
		==> Unique  => it will be unique
		==> Check ==> it will insert the values based on the conditions
		==> in this all three constraints not null can be write beside datatype
		Syntax and example:
			create table student(id int auto_increment not null,name varchar(50),gmail varchar(100),age int,unique(gmail),check(age>15),primary key(id));
SELECT AND WHERE CLAUSE:
		==> where clause is used to filter the data from table
		in where clause we have following filtering operations
			==> equality
			==> lessthan or greater than
			select name,age,gender from student;
	select name n,age a,gender g from student;
	select * from student where age>22;
	select * from student where age=22;
	select marks m from student where id=8;
	select id roll_no,marks m from student where id<8;
	select * from student where age<>22; -- not equal
	select * from student where age between 21 and 22;
	select * from student where age in(22,23,24);
	select * from student where name like '%1%';
	select * from student where name like '1%';
	select * from student where name like '%1';
Aggregrate functions in sql:
	==> count
	==> max
	==> min
	==> sum
	==> avg
	==> distinct
	Example:
		select count(name) from student where marks>95;
		select avg(marks) from student;
		select count(*) from student where marks>90;
		select max(marks) from student;
		select min(marks) from student;
		select count(marks) from student;
		select count(distinct marks) from student;
Joins in sql:
	==> Joins are used to join the different table
	Types of joins
		==> Inner join (common elemnets between two tables)
		==> Left join (common elemnets + left table)
		==> Outer join (full data) ==> My sql won't support but concept was same
		==> Right join (common elemnets + right table)
		==> Self join
		Joins are used to combined the data between different tables
		
		Syntax:
		select * from <table-name> as t1 <join> <table-name> as t2 on <comdition>
		Example:
			-- inner join (common data between two tables)
			show tables;
			select t1.id,t1.name from student as t1 inner join marks as t2 on t1.id=t2.id;
			select * from student as t1 inner join nsc as t2 on t1.id>t2.id;
			select * from student as t1 inner join nsc as t2 on t1.id<t2.id;
			-- left join (common data + left table data)
			select * from student;
			select * from nsc;
			show tables;
			select * from sports;
			select t1.id,t1.name,t2.sports from student as t1 left join sports as t2 on t1.id>t2.id;
			-- Right join (common data + right table data)
			select * from student as t1 right join sports as t2 on t1.id<t2.id;
			select * from marks;
	Self join: *(join on same table)
		==> self join is used when you want compare the data in same table
		==> For this we will use inner join as join on same table
		Example:
			select * from student as t1 inner join student as t2 on t1.marks<t2.marks;
			select * from student as t1 inner join student as t2 on t1.age>t2.age;
CLAUSES:
	==> Order by (like putting results in an order) 
		There are 2 types of orders
		1) ascending
		2) descending
		Example:
			select * from student order by marks;
			select * from student order by marks desc;
			select * from student order by marks desc,age desc; ==> you can give 2 coloumn names also if 2 persons have same name then it will 
			order by using age
	==> Group by (like grouping the result)
		Example:
			select sports,count(*) as no_of_students,avg(marks) from student group by sports order by no_of_students desc;
			select sports,age,count(*) as no_of_students,avg(marks) from student group by sports,age order by no_of_students desc,age;
	==> Having:
			Having clause used when group by condition used
			Syntax:
				select * from <table-name> group by <coloumn> having <condition>
			Example:
				select sports,count(name) c,avg(marks) as avg from student group by sports having c>=3 and avg>=89 order by c desc;
	==> Ranks:
		==> in ranks we have three functions
			1)rank()
			Example:
				select id,name,marks,rank() over(order by marks desc,age desc) as students_rank from student; -- rank function will skip the rank if both results are same
			2)row_number() -- row_number function will give number to the row
			Example:
				select id,name,marks,row_number() over(order by marks desc,age desc) as students_rank from student;
			3)dense_rank() -- it is a proper one and it will give rank occurately independednt of row numbers
			Example:
				select id,name,marks,dense_rank() over(order by marks desc,age desc) as students_rank from student;
UNION AND INTERSECT:
	==> UNION -- it will combine total_rows in 2 select queries
		Example:
			select * from student where sports='football'
			union
			select * from student where sports='volleyball';
	==> INTERSECT -- it will give common elemnets in 2 select queries -- it won't support in my sql
			select * from student where sports='football'
			intersect
			select * from student where sports='volleyball';
SUBQUERIES:
	There are 2 types of subqueries
	1) normal subqueries    -- only one time execution of the subqueri will occur
	2) corelated subqueries -- for every row the subqueri will execute
	
	==> Normal subqueries:
		Example:
			select id,name from student where sports='football' and marks>(select avg(marks) from student where sports='cricket');
	==> corelated subqueries:
		Example:
			select salary as nth_highest_salary from employee as t1 where 0=(select count(*) from employee as t2 where t1.salary<t2.salary);
			in above subqueri it will print the no of employees who has more salary in t2 compared to t1 i.e. in employee table
Normalization in Database:
	normalization:
		==> Normalization is nothing but organazing the data to avoid it redudancy and anomolies
		==> To avoid duplication
	==> There are 3 types of normalization
		1) 1NF normalization
		2) 2NF normalization
		3) 3NF normalization
		4) BCNF normalization
		
		1NF normalization:
			==> To remove insert anomolies
			==> To remove delete anomolies
			==> To remove update anomolies
			==> The coloumns are unordered
			==> Rows are unordered
			==> There is duplicated data
			==> The insertion and updation of element to a row should be unique
		2NF normalization:
			==> Table should be in 1NF
			==> There is no partial dependency
			    if we have multiple coloumns has prime attributes then another non-primary attribute partially depends on one of primary attribute
		3NF normalization
			==> Table should be in 2NF normalization
			==> it shouldn't have transitive dependencies
				if in table non-prime attribute depends on another non-primary attribute
		BCNF(BOYCEE CODD) normalization or 4NF normalization: (it's very rare)
			==> Table should be in 3NF normalization
			==> prime atrribute shouldn't depend upon non-prime attribute
Views in sql:(virtual tables) 
	==> it is used to access the data in efficient and secure way
	==> There is no physical exsitance for the table
	Example:
		create view my_view as select * from employee;
		select * from my_view;
		create view max_salary1 as select salary from employee as t1 where 0=(select count(*) from employee as t2 where t1.salary<t2.salary);
		select * from max_salary1;
Stored procedures in mysql:
	For example we have complex queries to use it multiple times we can use stored procedures like aliasing
	Synatx:
		delimiter //
		create <procedure-name> begin <query>; end//
		Example:
			delimiter //
			create procedure my_procedure() begin select * from employee where salary=5000;
			end 
			
			call my_procedure() ## for calling procedure
			
			Procedure with parameters;
			Synatx:
				delimiter //
				create <procedure-name(parameter data_type)> begin <query>; end//
			Example:
				delimiter //
				create procedure my_procedure2(e_salary int) begin select * from employee where salary=e_salary;
				end //
				call my_procedure2(45000)
Indexes in mysql:
	=> if index there the search will go there automatically
	==> it's a time saving query
	Synatx:
		create index <index-name> on <table-name> (<column_name> asc);
	Example:
		create index salary_index on employee (salary asc);
	
				
			
			
		
	
	
			
				
		
	
				
			
		

	
		



	

	
	

		
	